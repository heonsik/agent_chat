# 프로젝트 기획서 (초안)

## 1. 프로젝트 개요

### 1.1 프로젝트명
- agent_chat (가게 세계관 기반 AI Agent UI/오케스트레이션)

### 1.2 프로젝트 목표
- 해결하고자 하는 문제:
  - 멀티 스레드/멀티 작업 흐름에서 **상태 가시성**과 **사용자 승인 흐름**이 분리되지 않아 혼란이 발생
  - 툴 실행과 리소스 경쟁(그룹락/재고) 처리의 일관된 정책이 필요
- 기존 솔루션의 한계:
  - 장시간 실행되는 툴(예: 네비) 수행 중에는 같은 대화에서 다른 지시를 병렬로 처리하기 어려움
  - 사용자는 완료될 때까지 기다리거나 새 대화를 열어야 하며, 이때 기존 대화의 툴 실행 상태가 공유되지 않음
  - 대화 간 상태 단절로 동일 툴의 중복 실행/충돌이 발생할 수 있어 작업 조율이 어려움
- AI Agent로 해결하고자 하는 핵심 과제:
  - 단일 입력 스트림(음성/사진/영상) 환경에서도 동일한 작업 흐름 유지() 마이크 등 한 스트림 입력만 가능한 경우에도 새 대화/스트림 없이 병행 작업 처리)  - 향후 목표
  - GeneralManager → JobManager → WorkerPool → JobRunner 흐름 표준화
  - 툴박스 개념으로 ToolSpec(설명서/재고) 단일 소스 관리 + ToolRuntime 라우팅으로 실행을 분기해 확장성 확보
  - UI에서 상태/로그/승인 흐름을 명확히 표시

### 1.3 기대 효과
| 구분 | 기대 효과 | 측정 지표 |
|---|---|---|
| 정량적 | 작업 처리 흐름 단축 | 평균 처리 시간 |
| 정성적 | 승인/충돌 처리의 명확성 | 사용자 피드백 |

### 1.4 대상 사용자
- 멀티 작업을 동시에 처리해야 하는 운영자/관리자
- 승인/대기/취소 등 상태를 명확히 확인해야 하는 사용자

## 2. 기술 아키텍처

### 2.1 시스템 구성도
- [시스템 아키텍처 다이어그램 삽입]

### 2.2 사용 기술 스택
| 구분 | 기술/도구 | 선정 사유 |
|---|---|---|
| UI | PySide6 (PyDracula 템플릿) | 데스크톱 UI 기반, 빠른 프로토타입 |
| Framework | LangGraph (고정 사용) | JobRunner 흐름을 그래프 기반으로 단순화 |
| Tool Runtime | ToolSpec + Adapter 구조 | local/mcp/skills 확장 대응 |
| 배포 환경 | Windows | 운영 환경 기준 |

### 2.3 데이터 소스 및 처리 방식
- 현재 단계: 외부 데이터 소스 없음 (툴 호출 중심)
- 향후 확장: 문서/DB/외부 API 연동 고려

## 3. RAG 파이프라인 설계
- 현재 MVP 범위에서는 RAG 미사용 (향후 필요 시 추가)

## 4. Agent 설계

### 4.1 Agent 유형
- Plan-and-Execute 기반 (GeneralManager가 계획 생성 후 JobRunner가 실행)

### 4.2 Tools 정의
| 도구명 | 설명 | 입력 | 출력 |
|---|---|---|---|
| NavTool | 목적지 설정/경로 안내 | destination | 결과 상태 |
| MovieTool | 영화 실행 | title | 결과 상태 |
| SongTool | 노래 재생 | name | 결과 상태 |
| WeatherTool | 날씨 조회 | city | 날씨 정보 |

### 4.3 State 설계
- Job/Worker 상태: RUNNING / WAITING_CONFIRM / DONE / FAILED / CANCELED
- Tool 상태: acquired / locked
- UI 상태: waiting_lock / waiting_confirm

### 4.4 Human-in-the-Loop 전략
| 시나리오 | 개입 시점 | 처리 방식 |
|---|---|---|
| 툴 승인 필요 | confirmPolicy=always | 승인/거부 |
| 락 충돌 | 재고/그룹락 잠김 | 대기/취소/중단 |

### 4.5 프롬프트 조립/관리 전략
- 역할별 최소 컨텍스트 조립(Planner/Tool-Chooser/Param/Reporter)
- 고정 지침(System/Role) + 가변 컨텍스트(요약 히스토리/메모리/툴설명) 분리
- ToolSpec은 단일 소스에서 필요한 툴만 요약 주입
- 단계별로 서로 다른 프롬프트를 사용하여 토큰 절약과 정확도 향상

### 4.6 로그/근거 주입 전략
- 사용자 UI: 전체 로그 저장 및 옵션 표시
- LLM: 기본은 요약 상태만 주입, 필요 시에만 로그 발췌
- “필요 시” 조건은 규칙 기반(실패/예외, 사용자 근거 요구, 재시도 판단 등)

## 5. 구현 계획

### 5.1 개발 일정
| 단계 | 주요 활동 | 산출물 | 기간 |
|---|---|---|---|
| 1단계 | 구조 설계 및 폴더 정리 | 설계 문서 | 1주 |
| 2단계 | ToolSpec/Inventory/Runtime 구현 | 런타임 MVP | 1주 |
| 3단계 | JobRunner/이벤트/UI 연결 | 동작 데모 | 1주 |
| 4단계 | 통합/테스트 | 테스트 리포트 | 1주 |

### 5.2 리소스 요구사항
- 개발자 1~2명
- Windows 개발 환경

### 5.3 위험 요소 및 대응 방안
| 위험 요소 | 영향도 | 발생 가능성 | 대응 방안 |
|---|---|---|---|
| 툴 런타임 확장 복잡도 | 중 | 중 | Adapter 구조 유지 |
| UI/백엔드 동기화 이슈 | 중 | 중 | 이벤트 버스 통합 |

## 6. 평가 계획

### 6.1 평가 지표
| 평가 영역 | 지표 | 측정 방법 | 목표값 |
|---|---|---|---|
| 처리 흐름 | 상태 전환 정확도 | 시나리오 테스트 | 100% |
| 안정성 | 예외 처리 성공 | 오류 재현 테스트 | 100% |

### 6.2 테스트 시나리오
- 락 충돌 시 대기/취소/중단 처리
- 승인 필요 툴 실행/거부 처리

### 6.3 성공 기준
- JobRunner 최소 루프가 정상 실행
- UI에서 상태/승인 흐름이 명확히 표시
