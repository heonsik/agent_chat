# 에이전트 세계관(역할/클래스) 정리 문서

이 문서는 ‘가게’ 비유(현실 세계관)를 기반으로, 프로그램 구성 요소(클래스/컴포넌트)의 **역할, 책임, 상호작용**을 개발 관점에서 정리합니다.  
핵심 목표는 “설계 의도를 누구나 같은 그림으로 이해”하는 것입니다.

---

## 0) 한 줄 요약

- **고객(사용자)**의 요청을 **총괄매니저(메인 스레드)**가 접수하고,  
- **통역가(LLM)**에게 “맥락이 포함된 편지”로 해석/계획을 요청한 뒤,  
- **서버들(워커 스레드)**이 **공구박스(툴 인벤토리)**에서 공구(툴)를 대여/실행하며 일을 끝까지 수행한다.  
- 모든 진행상태는 **전광판(Dashboard)**에서 상시 표시되고, 승인 필요 시 **작업 패널**에서 승인/취소를 한다.

---

## 1) 캐릭터(클래스) 소개 및 책임

### 1) 통역가 (Interpreter / LLM Service)
**정의**: LLM 서비스. “편지(문자열)”로만 소통하며, 매 요청마다 맥락을 새로 주어야 한다.

- 특징
  - **상태 없음(stateless)**: 매 호출마다 컨텍스트(지침+히스토리+메모리+툴 설명서)를 편지에 동봉
  - 요청마다 “통역가”가 바뀔 수 있으므로 **항상 히스토리/요약을 포함**해야 동일 맥락 유지
  - 역할 분화 가능(전문 통역가)
    - Planner(요청 해석/계획/투두 생성)
    - Tool-Chooser(툴 선택/파라미터 구성)
    - Summarizer(히스토리 요약/중요정보 추출·축출)
    - Reporter(고객에게 보여줄 답변 작성)
    - Solver(툴 없이 해결 가능한 단계 처리)

- I/O 예시
  - 입력(편지): system prompt + history + memory + toolbox specs + user request
  - 출력: 계획(Plan), todo 리스트, tool call 스펙, 사용자 답변

---

### 2) 고객 (Customer / User)
**정의**: 외국인 고객. 프로그램이 고객의 언어를 직접 이해하지 못하므로 항상 통역가를 거친다.

- 특징
  - 고객 입력 → (통역가) → 내부 실행 → (통역가) → 고객 출력
  - 툴이 잠겼을 때(락/재고 부족) “대기/취소/중단” 의사를 UI로 결정

---

### 3) 총괄매니저 (General Manager / Main Thread)
**정의**: 프로그램의 메인 스레드. 고객 입력을 접수하고 업무를 “계획/배차”한다.

- 주요 책임
  - 고객 입력 수신 및 라우팅
  - 컨텍스트 조립: system 지침 + history + (장/단기) 메모리 + 툴 설명서
  - Provider를 통해 LLM I/O 형식을 정규화
  - 통역가(Planner) 호출로:
    - 요청을 구체화
    - todo list 생성
    - 즉시 답변 가능 여부 판단
  - todo list가 생기면 JobManager에 **작업지시서(Job Ticket)** 제출
  - **메인은 항상 입력대기**로 복귀(동시성 확보)

- 핵심 원칙
  - 메인은 “계획과 배차”가 주임무, “실행”은 서버(워커)가 담당

---

### 4) 서버들 (Servers / Worker Threads, TodoExecutor)
**정의**: 총괄매니저가 발급한 작업지시서(Job)를 받아 실제로 일을 한다. (todo executor)

- 주요 책임
  - todo list를 **순서대로** 실행(한 Job 안에서는 순차 진행)
  - todo마다:
    - 툴이 필요한지 판단(LLM 호출 가능)
    - 필요하면 공구박스에서 공구(툴) 대여 후 실행
    - 결과/로그/근거 저장(State/Evidence Update)
  - 공구가 잠겨있거나 승인 필요하면:
    - **사용자 확인 인터럽트**로 UI에 대기(노란 깜빡)
    - 사용자 선택(대기/취소/중단)에 따라 재시도/종료/교체

- 성능 우선 정책에서의 특징
  - “정확한 실행”을 위해 LLM 호출을 더 적극적으로 사용 가능
  - 결과 요약(근거화)도 LLM을 활용하여 사용자에게 이해 가능한 보고로 변환

---

### 5) 프로그램 (agent_chat / Store UI)
**정의**: 고객이 접하는 “가게” 그 자체. 채팅 + 전광판 + 작업 패널을 제공한다.

- 주요 UI 구성
  - Chat View: 고객 대화
  - Dashboard(전광판): 워커/잡 상태 아이콘
  - Job Panel(작업방): 특정 Job의 채팅/로그/승인 버튼
  - Log Stream: 툴 로그 실시간 표시
  - Confirm Controls: 승인/대기/취소/중단

- 상태 표시 규칙(예시)
  - 실행중: 기본 아이콘
  - 승인대기: 노란색 깜빡
  - 성공: 초록색 깜빡
  - 실패: 빨간색 깜빡

---

### 6) 프로바이더 (Provider Adapter / 사투리 교정가)
**정의**: LLM 서비스별 입출력 형식을 통일하는 어댑터.

- 역할
  - Prompt/Response 정규화
  - JSON schema / tool-call 포맷 변환
  - 다양한 LLM(통역가)이 있어도 내부 실행 파이프라인은 동일하도록 보장

- 예시 API
  - `NormalizePrompt(ctx) -> provider_prompt`
  - `ParsePlan(llm_response) -> Plan`
  - `ParseToolSpec(llm_response) -> ToolCallSpec`
  - `NormalizeOutput(text) -> final_user_text`

---

### 7) 공구박스 (Toolbox / Inventory + Group Lock)
**정의**: 툴(공구)들을 모아둔 인벤토리. 수량/그룹락/대여현황을 관리한다.

- 핵심 개념
  - **툴 수량(capacity)**: SongTool(2)처럼 동시에 2개까지
  - **무제한(infinite)**: WeatherTool처럼 락 없이 언제든 실행
  - **그룹락(Group Lock / 모니터박스)**: 컨테이너 단위 상호배제
    - 예: MonitorBox 안에 NavTool(1), MovieTool(1)
    - NavTool을 대여하면 MonitorBox가 점유되어 MovieTool도 사용 불가(락 효과)

- 동작 규칙
  - 서버(워커)가 툴 실행 필요 → Toolbox.Acquire 요청
  - Acquire 결과:
    - acquired(대여 성공) → 실행 후 Release로 반납
    - locked(점유중) → 사용자 확인 인터럽트(대기/취소/중단)로 처리

- ToolSpec(사용 설명서)에 담길 정보(권장)
  - 호출 매개변수 스키마, 결과 포맷
  - capacity(수량), groupKey(그룹락 키), confirmPolicy(승인 필요 여부)
  - 실행 특성(longtime 여부 등)

---

### 8) 전광판 (Dashboard / Status Board)
**정의**: 어떤 서버(워커)가 어떤 일을 하고 있는지 상시 표시하는 UI 관제판.

- 기능
  - Job/Worker 상태 이벤트 수신
  - 색상/깜빡임으로 상태 표현
  - 아이콘 클릭 시 해당 Job Panel 오픈
  - 승인 대기 시 사용자 행동을 유도(노랑)

---

## 2) 핵심 정책(세계관 규칙을 코드 정책으로)

### 2.1 통역가 호출은 “편지” 단위
- 모든 LLM 호출은 문자열 입력/출력
- 매 호출마다 context 포함(히스토리/요약/메모리/툴설명서)

### 2.2 메인은 절대 블로킹하지 않는다
- todo가 생기면 Job으로 제출하고 바로 입력대기로 복귀
- 실행은 워커가 담당(동시성)

### 2.3 한 Job 안에서는 todo는 순차 실행
- 특히 네비 완료 후 다음 행동처럼 “의존 순서”가 중요한 경우를 자연스럽게 지원

### 2.4 공구 잠김(락/재고부족) 시 사용자 확인 인터럽트
- 자동으로 다른 todo로 넘어가지 않고(순차 보장)
- 사용자에게 대기/취소/중단 등 선택을 제공

---

## 3) 예시 시나리오 (현실 세계관 그대로)

### 시나리오 A: 네비 중에도 노래는 가능
1) 고객: “목적지 A로 네비 켜줘”  
2) 메인: Planner 호출 → todo 생성 → 서버1 Job 실행  
3) 서버1: MonitorBox 대여 → NavTool 실행(그룹락 점유)  
4) 고객: “노래 불러줘”  
5) 메인: 새로운 Job 생성 → 서버2 실행  
6) 서버2: SongTool(2) 중 1개 대여 → 노래 실행(동시 가능)  
7) 전광판: 서버1(네비 실행중), 서버2(노래 실행중)

### 시나리오 B: 네비 중 영화는 충돌 → 사용자 선택
1) 네비 실행 중(MonitorBox 점유)  
2) 고객: “영화도 틀어줘”  
3) 서버2: MovieTool 필요 → MonitorBox 잠김 → 사용자 확인 인터럽트  
4) Job Panel에서 선택:
   - 기다리기: 네비 종료까지 대기 후 MovieTool 실행
   - 취소: 영화 Job 종료
  - 중단(stop_other): 충돌 Job(네비, MonitorBox 점유) 취소 후 영화 실행

### 시나리오 C: 노래툴 2개가 모두 사용 중일 때
1) 서버2/서버3이 SongTool 2개 모두 사용 중  
2) 고객: “노래 하나 더!”  
3) 서버4: SongTool 재고 없음 → 사용자 확인 인터럽트(대기/취소)

---

## 4) 관련 다이어그램 파일

- 플로우차트(세계관 동작): `agent_world_flowchart_v3.md`
- 클래스/상태머신(구조/상태): `agent_world_models_v2.md`

---

끝.
